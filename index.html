<script type="text/babel">
/* ===== YEAT STATS — NOVEMBER-PROOF + GITHUB PAGES FIXED ===== */
const REPO_USER = 'treat3d6';
const REPO_NAME = 'fr';
const BRANCH = 'main';  // or 'gh-pages'
const RAW_BASE = `https://raw.githubusercontent.com/${REPO_USER}/${REPO_NAME}/${BRANCH}/`;
const CACHE_KEY = 'yeatstats_nov2025_v2';

const formatNum = n => (n||0).toLocaleString();
const toNum = s => parseInt((''+s).replace(/,/g,'').trim(),10)||0;
const dateToStr = d => d.toISOString().split('T')[0];
const strToDate = s => new Date(s + 'T00:00:00Z');

/* === FIXED: Find closest CSV to 28 days ago (REAL DATE MATH) === */
function find28DayOld(availableDates, todayStr) {
  const target = new Date(todayStr);
  target.setDate(target.getDate() - 28);
  const targetTime = target.getTime();

  let best = null;
  let bestDiff = Infinity;

  for (const d of availableDates) {
    const diff = Math.abs(strToDate(d) - targetTime);
    if (diff < bestDiff) {
      bestDiff = diff;
      best = d;
    }
  }
  return best; // Always returns a real file
}

/* === App Component === */
function YeatStats() {
  const [activeTab, setActiveTab] = React.useState('songs');
  const [searchTerm, setSearchTerm] = React.useState('');
  const [sortConfig, setSortConfig] = React.useState({ key: 'streams', direction: 'desc' });
  const [songs, setSongs] = React.useState([]);
  const [historyData, setHistoryData] = React.useState({});
  const [albumHistoryData, setAlbumHistoryData] = React.useState({});
  const [totalHistoryData, setTotalHistoryData] = React.useState([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState(null);
  const [selectedItems, setSelectedItems] = React.useState([]);
  const [showTotalChart, setShowTotalChart] = React.useState(false);
  const [latestDate, setLatestDate] = React.useState(null);
  const [statsData, setStatsData] = React.useState({
    headers: ['Total', 'Lead', 'Solo', 'Features'],
    rows: [
      { label: 'Streams', values: [0, 0, 0, 0] },
      { label: 'Daily', values: [0, 0, 0, 0] },
      { label: 'Tracks', values: [0, 0, 0, 0] }
    ]
  });

  const [albums, setAlbums] = React.useState([
    { title: "Up 2 Më", streams: 0, daily: 0, tracks: 0 },
    { title: "Lyfë", streams: 0, daily: 0, tracks: 0 },
    { title: "2 Alivë", streams: 0, daily: 0, tracks: 0 },
    { title: "2093", streams: 0, daily: 0, tracks: 0 },
    { title: "AftërLyfe", streams: 0, daily: 0, tracks: 0 },
    { title: "4L", streams: 0, daily: 0, tracks: 0 },
    { title: "Trëndi", streams: 0, daily: 0, tracks: 0 },
    { title: "Alivë", streams: 0, daily: 0, tracks: 0 },
    { title: "LYFESTYLE", streams: 0, daily: 0, tracks: 0 },
    { title: "DANGEROUS SUMMER", streams: 0, daily: 0, tracks: 0 }
  ]);

  React.useEffect(() => {
    loadAllData();
  }, []);

  const loadAllData = async () => {
    try {
      setLoading(true);
      setError(null);

      // 1. Discover all CSV dates (last 365 days)
      const end = new Date();
      const start = new Date(); start.setDate(start.getDate() - 365);
      const possibleDates = [];
      for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
        possibleDates.push(dateToStr(d));
      }

      const existingDates = (await Promise.all(
        possibleDates.map(async d => {
          try {
            const res = await fetch(RAW_BASE + d + '.csv', { method: 'HEAD' });
            return res.ok ? d : null;
          } catch { return null; }
        })
      )).filter(Boolean).sort().reverse();

      if (!existingDates.length) throw new Error('No CSV files found. Check repo and GitHub Pages.');

      const todayStr = existingDates[0];
      const oldStr = find28DayOld(existingDates, todayStr); // ← FIXED
      setLatestDate(todayStr);

      // 2. Load latest + 28-day-old
      const loadCSV = async (d) => {
        const res = await fetch(RAW_BASE + d + '.csv?t=' + Date.now());
        const text = await res.text();
        return Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          transformHeader: h => h.trim()
        }).data;
      };

      const [latestData, oldData] = await Promise.all([loadCSV(todayStr), loadCSV(oldStr)]);

      // 3. Build history (background)
      const rawHistory = {};
      const rawAlbumHistory = {};
      const rawTotalHistory = [];

      for (const date of existingDates) {
        const rows = await loadCSV(date);
        let dailySum = 0, totalSum = 0;

        rows.forEach(row => {
          const title = row.Song || '';
          const album = row.Album || '';
          const daily = toNum(row['Spotify daily']);
          const total = toNum(row['Spotify total']);
          if (!title || !album) return;

          const key = title.toLowerCase() === 'already rich' ? 'Already Rich' : `${title}|${album}`;
          if (!rawHistory[key]) rawHistory[key] = [];
          rawHistory[key].push({ date, streams: total, daily });

          if (!rawAlbumHistory[album]) rawAlbumHistory[album] = [];
          const albumEntry = rawAlbumHistory[album].find(e => e.date === date);
          if (albumEntry) {
            albumEntry.streams += total;
            albumEntry.daily += daily;
          } else {
            rawAlbumHistory[album].push({ date, streams: total, daily });
          }

          dailySum += daily;
          totalSum += total;
        });

        rawTotalHistory.push({ date, streams: totalSum, daily: dailySum });
      }

      // Sort histories
      Object.keys(rawHistory).forEach(k => rawHistory[k].sort((a,b) => strToDate(a.date) - strToDate(b.date)));
      Object.keys(rawAlbumHistory).forEach(k => rawAlbumHistory[k].sort((a,b) => strToDate(a.date) - strToDate(b.date)));
      rawTotalHistory.sort((a,b) => strToDate(a.date) - strToDate(b.date));

      setHistoryData(rawHistory);
      setAlbumHistoryData(rawAlbumHistory);
      setTotalHistoryData(rawTotalHistory);

      // 4. Process latest data
      processCSVData(latestData, oldData);
      setLoading(false);

    } catch (e) {
      console.error(e);
      setError(e.message || 'Failed to load data');
      setLoading(false);
    }
  };

  const processCSVData = (latestRows, oldRows) => {
    const oldMap = {};
    oldRows.forEach(r => {
      const k = (r.Song||'').toLowerCase() === 'already rich' ? 'Already Rich' : `${r.Song}|${r.Album}`;
      oldMap[k] = toNum(r['Spotify total']);
    });

    const songMap = {};
    latestRows.forEach(r => {
      const title = r.Song || '';
      const album = r.Album || '';
      if (!title) return;
      const key = title.toLowerCase() === 'already rich' ? 'Already Rich' : `${title}|${album}`;
      const total = toNum(r['Spotify total']);
      const daily = toNum(r['Spotify daily']);
      const old = oldMap[key] || 0;
      const growth = old > 0 ? ((total - old) / old) * 100 : (old === 0 && total > 0 ? 999999 : 0);
      songMap[key] = { title, album, streams: total, daily, growth };
    });

    const processedSongs = Object.values(songMap);
    setSongs(processedSongs);
    calculateStats(processedSongs);
  };

  const calculateStats = (processedSongs) => {
    const totalStreams = processedSongs.reduce((s, song) => s + song.streams, 0);
    const totalDaily = processedSongs.reduce((s, song) => s + song.daily, 0);
    const totalTracks = processedSongs.length;

    const featureTracks = processedSongs.filter(s => s.album === "Features");
    const featureStreams = featureTracks.reduce((s, song) => s + song.streams, 0);
    const featureDaily = featureTracks.reduce((s, song) => s + song.daily, 0);
    const featureCount = featureTracks.length;

    const leadTracks = processedSongs.filter(s => s.album !== "Features");
    const leadStreams = leadTracks.reduce((s, song) => s + song.streams, 0);
    const leadDaily = leadTracks.reduce((s, song) => s + song.daily, 0);
    const leadCount = leadTracks.length;

    const soloTracks = leadTracks.filter(s => !s.title.toLowerCase().includes("feat."));
    const soloStreams = soloTracks.reduce((s, song) => s + song.streams, 0);
    const soloDaily = soloTracks.reduce((s, song) => s + song.daily, 0);
    const soloCount = soloTracks.length;

    setStatsData({
      headers: statsData.headers,
      rows: [
        { label: 'Streams', values: [totalStreams, leadStreams, soloStreams, featureStreams] },
        { label: 'Daily', values: [totalDaily, leadDaily, soloDaily, featureDaily] },
        { label: 'Tracks', values: [totalTracks, leadCount, soloCount, featureCount] }
      ]
    });

    const albumStats = albums.map(a => {
      const songs = processedSongs.filter(s => s.album === a.title);
      return {
        title: a.title,
        streams: songs.reduce((s, song) => s + song.streams, 0),
        daily: songs.reduce((s, song) => s + song.daily, 0),
        tracks: songs.length
      };
    });
    setAlbums(albumStats);
  };

  // [Rest of your UI code — unchanged below]
  const formatNumber = (num) => num.toLocaleString('en-US');
  const formatDate = (dateStr) => {
    if (!dateStr) return '';
    const [y, m, d] = dateStr.split('-');
    return `${parseInt(m)}/${parseInt(d)}/${y.slice(2)}`;
  };

  const requestSort = (key) => {
    setSortConfig(p => ({
      key,
      direction: p.key === key && p.direction === 'desc' ? 'asc' : 'desc'
    }));
  };

  const getSortedData = (data) => {
    if (!sortConfig.key) return data;
    return [...data].sort((a, b) => {
      const va = a[sortConfig.key] ?? '';
      const vb = b[sortConfig.key] ?? '';
      if (typeof va === 'string') return sortConfig.direction === 'asc' ? va.localeCompare(vb) : vb.localeCompare(va);
      return sortConfig.direction === 'asc' ? va - vb : vb - va;
    });
  };

  const filteredData = {
    songs: getSortedData(songs.filter(s => 
      s.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
      s.album.toLowerCase().includes(searchTerm.toLowerCase())
    )),
    albums: getSortedData(albums.filter(a => a.title.toLowerCase().includes(searchTerm.toLowerCase())))
  };

  const getSortIndicator = (key) => sortConfig.key === key ? (sortConfig.direction === 'asc' ? ' Up' : ' Down') : '';

  const handleItemClick = (item) => {
    const key = activeTab === 'songs' 
      ? (item.title.toLowerCase() === 'already rich' ? 'Already Rich' : `${item.title}|${item.album}`)
      : item.title;
    setSelectedItems(p => p.includes(key) ? p : [...p, key]);
  };

  return (
    <div className="w-full max-w-6xl mx-auto p-2 sm:p-6">
      <div className="bg-black border border-white/10 rounded-lg shadow-2xl p-3 sm:p-6">
        <div className="mb-4 sm:mb-8">
          <h1 className="text-xl sm:text-2xl font-bold mb-2 text-white">Yeat Spotify Stats</h1>
          <p className="text-xs sm:text-sm text-white/60">{formatDate(latestDate)}</p>
          {error && <div className="mt-2 text-sm text-red-500">Error: {error}</div>}
        </div>

        {loading ? (
          <div className="text-center py-8 text-white/60">Loading data... Please wait.</div>
        ) : (
          <>
            {/* [Your stats table, tabs, search, table, charts — unchanged] */}
            {/* Paste the rest of your original UI code here */}
            {/* I'll keep it short — just replace the script block */}
          </>
        )}
      </div>
    </div>
  );
}

/* === Keep your TotalChart, ComparisonChart, etc. below === */
// ... (your existing chart components)

window.onload = () => {
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<YeatStats />);
};
</script>
